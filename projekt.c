// Bump mapping lab by Ingemar// Revised 2013 to use MicroGlut, VectorUtils3 and zpr// gcc lab1-2.c ../common/*.c -lGL -o lab1-2 -I../common#ifdef __APPLE__// Mac	#include <OpenGL/gl3.h>	#include "MicroGlut.h"	// uses framework Cocoa#else	#ifdef WIN32// MS		#include <windows.h>		#include <stdio.h>		#include <GL/glew.h>		#include <GL/glut.h>	#else// Linux		#include <stdio.h>		#include <GL/gl.h>		#include "MicroGlut.h"//		#include <GL/glut.h>	#endif#endif#include "LoadTGA.h"#include "VectorUtils3.h"#include "GL_utilities.h"#include "loadobj.h"#include "zpr.h"// initial width and heights#define W 512#define H 512#define NEAR 1.0#define FAR 150.0#define RIGHT 0.5#define LEFT -0.5#define TOP 0.5#define BOTTOM -0.5#define NUM_LIGHTS 4void OnTimer(int value);GLfloat square[] = {                            -1,-1,0,                            -1,1, 0,                            1,1, 0,                            1,-1, 0};GLfloat squareTexCoord[] = {                             0, 0,                             0, 1,                             1, 1,                             1, 0};GLuint squareIndices[] = {0, 1, 2, 0, 2, 3};mat4 projectionMatrix,        viewMatrix, rotateMatrix; // viewMatrix controlled by zpr.cmat4 modelMatrix = {{ 3.0, 0.0, 0.0, 0.0,                              0.0, 3.0, 0.0, 0.0,                              0.0, 0.0, 3.0, 0.0,                              0.0, 0.0, 0.0, 1.0}};mat4 sceneModelMatrix = {{ 2.0, 0.0, 0.0, 0.0,                            0.0, 2.0, 0.0, 1.0,                            0.0, 0.0, 2.0, 0.0,                            0.0, 0.0, 0.0, 1.0}};//----------------------Globals-------------------------------------------------Point3D cam, point, lightPosition;Model *bunny, *squareModel, *scene;FBOstruct *fbo1, *fbo2, *fbo3;GLuint shader = 0, phongshader = 0, passshader = 0 ;GLuint thicknessTex;unsigned int vsBuffer, vtBuffer; // Attribute buffers for Vs and Vt//-------------------------------------------------------------------------------------void init(void){	dumpInfo();  // shader info	// GL inits	glClearColor(0.1, 0.1, 0.3, 0);	glClearDepth(1.0);	glEnable(GL_TEXTURE_2D);	glEnable(GL_DEPTH_TEST);    glEnable(GL_CULL_FACE);    glCullFace(GL_BACK);            // Load shader    shader = loadShaders("shaders/projekt.vert", "shaders/projekt.frag");    phongshader = loadShaders("shaders/phong.vert", "shaders/phong.frag");    passshader = loadShaders("shaders/plaintextureshader.vert", "shaders/plaintextureshader.frag");    // Init FBOs	fbo1 = initFBO(W, H, 0);	fbo2 = initFBO(W, H, 0);	fbo3 = initFBO(W, H, 0);        squareModel = LoadDataToModel(            square, NULL, squareTexCoord, NULL,            squareIndices, 4, 6);	// load the model    bunny = LoadModelPlus("objects/bunny2/bunny_unwrap_noextras_blender.obj");    printf("%d vertices\n", bunny->numVertices);    printf("%d indices\n", bunny->numIndices);    // Load thickness map    LoadTGATextureSimple("objects/bunny2/bunny_unwrap_middle.tga", &thicknessTex);	// load the scenemodel    scene = LoadModelPlus("objects/scene.obj");    printf("%d vertices\n", scene->numVertices);    printf("%d indices\n", scene->numIndices);            cam = SetVector(3, 2, 3);    point = SetVector(0, 0, 0);    lightPosition = SetVector(-10,0.0,-10.0);	glutTimerFunc(5, &OnTimer, 0);    	zprInit(&viewMatrix, cam, point);  }void OnTimer(int value){	glutPostRedisplay();	glutTimerFunc(5, &OnTimer, value);}//-------------------------------callback functions------------------------------------------void display(void){    // This function is called whenever it is time to render    //  a new frame; due to the onTimer()-function below, this    //  function will get called several times per second        useFBO(fbo1, 0L, 0L);        glBindTexture(GL_TEXTURE_2D, thicknessTex);    //BUNNY    // Clear framebuffer & zbuffer	glClearColor(0.1, 0.1, 0.3, 0);    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    glUseProgram(shader);    glUniformMatrix4fv(glGetUniformLocation(shader, "projMatrix"), 1, GL_TRUE, projectionMatrix.m);    glUniformMatrix4fv(glGetUniformLocation(shader, "modelMatrix"), 1, GL_TRUE, modelMatrix.m);    glUniformMatrix4fv(glGetUniformLocation(shader, "viewMatrix"), 1, GL_TRUE, viewMatrix.m);        glUniform3f(glGetUniformLocation(shader, "camPosition"),cam.x,cam.y,cam.z);    glUniform1i(glGetUniformLocation(shader, "texUnit"), 0);    // Enable Z-buffering    glEnable(GL_DEPTH_TEST);    // Enable backface culling    glEnable(GL_CULL_FACE);    glCullFace(GL_BACK);    DrawModel(bunny, shader, "in_Position", "in_Normal", "in_TexCoord");        useFBO(0L, fbo1, 0L);       glClearColor(0.0, 0.0, 0.0, 0);    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    glUseProgram(passshader);    glUniform1i(glGetUniformLocation(passshader, "texUnit"), 0);    glDisable(GL_CULL_FACE);    glDisable(GL_DEPTH_TEST);    DrawModel(squareModel, passshader, "in_Position", NULL, "in_TexCoord");    glutSwapBuffers();        //BACKDROP    // glUseProgram(phongshader);        // glUniformMatrix4fv(glGetUniformLocation(phongshader, "projMatrix"), 1, GL_TRUE, projectionMatrix.m);    // glUniformMatrix4fv(glGetUniformLocation(phongshader, "viewMatrix"), 1, GL_TRUE, viewMatrix.m);    // glUniformMatrix4fv(glGetUniformLocation(phongshader, "modelMatrix"), 1, GL_TRUE, sceneModelMatrix.m);    // DrawModel(scene, phongshader, "in_Position", "in_Normal", "in_TexCoord");            //printf("camera.x %f \n", cam.x);}void reshape(GLsizei w, GLsizei h){    glViewport(0, 0, w, h);    GLfloat ratio = (GLfloat) w / (GLfloat) h;    projectionMatrix = perspective(70, ratio, 0.2, 1000.0);    glUniformMatrix4fv(glGetUniformLocation(shader, "projMatrix"), 1, GL_TRUE, projectionMatrix.m);}//-----------------------------main-----------------------------------------------int main(int argc, char *argv[]){    glutInit(&argc, argv);    glutInitDisplayMode(GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE);    glutInitContextVersion(3, 2); // Might not be needed in Linux    glutInitWindowSize(W, H);    glutCreateWindow ("bump mapping lab");    glutDisplayFunc(display);    glutTimerFunc(5, &OnTimer, 0);    glutReshapeFunc(reshape);    init();    zprInit(&viewMatrix, cam, point);        glutMainLoop();    exit(0);}