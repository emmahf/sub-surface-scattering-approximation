// Bump mapping lab by Ingemar// Revised 2013 to use MicroGlut, VectorUtils3 and zpr// gcc lab1-2.c ../common/*.c -lGL -o lab1-2 -I../common#ifdef __APPLE__// Mac	#include <OpenGL/gl3.h>	#include "MicroGlut.h"	// uses framework Cocoa#else	#ifdef WIN32// MS		#include <windows.h>		#include <stdio.h>		#include <GL/glew.h>		#include <GL/glut.h>	#else// Linux		#include <stdio.h>		#include <GL/gl.h>		#include "MicroGlut.h"//		#include <GL/glut.h>	#endif#endif#include "LoadTGA.h"#include "VectorUtils3.h"#include "GL_utilities.h"#include "loadobj.h"#include "zpr.h"// initial width and heights#define W 512  #define H 512#define NEAR 1.0#define FAR 150.0#define RIGHT 0.5#define LEFT -0.5#define TOP 0.5#define BOTTOM -0.5#define NUM_LIGHTS 4void OnTimer(int value);GLfloat square[] = {                            -1,-1,0,                            -1,1, 0,                            1,1, 0,                            1,-1, 0};GLfloat squareTexCoord[] = {                             0, 0,                             0, 1,                             1, 1,                             1, 0};GLuint squareIndices[] = {0, 1, 2, 0, 2, 3};mat4 projectionMatrix,        viewMatrix, rotateMatrix; // viewMatrix controlled by zpr.cmat4 modelMatrix = {{ 3.0, 0.0, 0.0, 0.0,                              0.0, 3.0, 0.0, 0.0,                              0.0, 0.0, 3.0, 0.0,                              0.0, 0.0, 0.0, 1.0}};mat4 sceneModelMatrix = {{ 1.0, 0.0, 0.0, 0.0,                            0.0, 1.0, 0.0, -1.8,                            0.0, 0.0, 1.0, 0.0,                            0.0, 0.0, 0.0, 1.0}};mat4 sphereModelMatrix = {{ 1.0, 0.0, 0.0, 0.0,                            0.0, 1.0, 0.0, 0.0,                            0.0, 0.0, 1.0, 0.0,                            0.0, 0.0, 0.0, 1.0}};mat4 normalMatrixScene = {{ 1.0, 0.0, 0.0, 0.0,                            0.0, 1.0, 0.0, 0.0,                            0.0, 0.0, 1.0, 0.0,                            0.0, 0.0, 0.0, 1.0}};mat4 normalMatrixBunny = {{ 1.0, 0.0, 0.0, 0.0,                            0.0, 1.0, 0.0, 0.0,                            0.0, 0.0, 1.0, 0.0,                            0.0, 0.0, 0.0, 1.0}};mat4 normalMatrix = {{ 1.0, 0.0, 0.0, 0.0,                            0.0, 1.0, 0.0, 0.0,                            0.0, 0.0, 1.0, 0.0,                            0.0, 0.0, 0.0, 1.0}};mat4 bottomModelMatrix = {{ 1.0, 0.0, 0.0, 0.0,                            0.0, 1.0, 0.0, -1.8,                            0.0, 0.0, 1.0, 0.0,                            0.0, 0.0, 0.0, 1.0}};mat4 side1ModelMatrix = {{ 1.0, 0.0, 0.0,  -9.0,                            0.0, 1.0, 0.0, 5.0,                            0.0, 0.0, 1.0, 0.0,                            0.0, 0.0, 0.0, 1.0}};mat4 side2ModelMatrix = {{ 1.0, 0.0, 0.0,  0.0,                            0.0, 1.0, 0.0, 5.0,                            0.0, 0.0, 1.0, -10.0,                            0.0, 0.0, 0.0, 1.0}};//----------------------Globals-------------------------------------------------Point3D cam, point, lightPosition;Model *bunny, *squareModel, *scene, *sphere, *bottom, *side1, *side2;FBOstruct *fbo_depth, *fbo2, *fbo3;GLuint phongshader = 0,         shader = 0, passShader = 0 , joinshader = 0,        lightShader = 0;GLuint thicknessTex;double moveX, moveValue;unsigned int vsBuffer, vtBuffer; // Attribute buffers for Vs and Vt//-------------------------------------------------------------------------------------void init(void){	dumpInfo();  // shader info	// GL inits	glClearColor(0.1, 0.1, 0.3, 0);	glClearDepth(1.0);	glEnable(GL_TEXTURE_2D);	glEnable(GL_DEPTH_TEST);    glEnable(GL_CULL_FACE);    glCullFace(GL_BACK);            // Load shader    shader = loadShaders("shaders/projekt.vert", "shaders/projekt.frag");    phongshader = loadShaders("shaders/phong.vert", "shaders/phong.frag");    passShader = loadShaders("shaders/plaintextureshader.vert", "shaders/plaintextureshader.frag");    joinshader = loadShaders("shaders/joinshader.vert", "shaders/joinshader.frag");    lightShader = loadShaders("shaders/illuminati.vert", "shaders/illuminati.frag");    // Init FBOs	fbo_depth = initFBO(W, H, 0);	fbo2 = initFBO(W, H, 0);	fbo3 = initFBO(W, H, 0);        squareModel = LoadDataToModel(            square, NULL, squareTexCoord, NULL,            squareIndices, 4, 6);	// load the model    bunny = LoadModelPlus("objects/bunny2/bunny_unwrap_noextras_blender.obj");    printf("%d vertices\n", bunny->numVertices);    printf("%d indices\n", bunny->numIndices);    // Load thickness map    LoadTGATextureSimple("objects/bunny2/bunny_unwrap_middle.tga", &thicknessTex);	// load the scenemodel    scene = LoadModelPlus("objects/scene_big.obj");    printf("%d vertices\n", scene->numVertices);    printf("%d indices\n", scene->numIndices);        // load the scenemodel    bottom = LoadModelPlus("objects/bottom.obj");    printf("%d vertices\n", bottom->numVertices);    printf("%d indices\n", bottom->numIndices);    // load the scenemodel    side1 = LoadModelPlus("objects/side1.obj");    printf("%d vertices\n", side1->numVertices);    printf("%d indices\n", side1->numIndices);    // load the scenemodel    side2 = LoadModelPlus("objects/side2.obj");    printf("%d vertices\n", side2->numVertices);    printf("%d indices\n", side2->numIndices);        // load sphere    sphere = LoadModelPlus("objects/sphere.obj");    printf("%d vertices\n", sphere->numVertices);    printf("%d indices\n", sphere->numIndices);    cam = SetVector(3, 2, 3);    point = SetVector(0, 0, 0);    lightPosition = SetVector(0.0,0.0,-9.0);    sphereModelMatrix = T(lightPosition.x, lightPosition.y, lightPosition.z);	glutTimerFunc(5, &OnTimer, 0);        moveValue = 0.01;    moveX = moveValue;	zprInit(&viewMatrix, cam, point);}void OnTimer(int value){       lightPosition.x += moveX;    sphereModelMatrix = Mult(sphereModelMatrix, T(moveX, 0.0, 0.0) );    if(lightPosition.x < -10.0){        moveX = moveValue;        printf("lightPosition.x %f \n", lightPosition.x);    }    else if(lightPosition.x > 10.0){         moveX = -moveValue;        printf("lightPosition.x %f \n", lightPosition.x);    }    //printf("lightPosition.x %f \n", lightPosition.x);	glutPostRedisplay();	glutTimerFunc(5, &OnTimer, value);}//-------------------------------callback functions------------------------------------------void useThicknessShader(FBOstruct *fbo){}void display(void){    // This function is called whenever it is time to render    //  a new frame; due to the onTimer()-function below, this    //  function will get called several times per second        //DRAW  __ALL__ PHONG OBJECTS TO THE SAME FBO (+ Depth test! )    useFBO(fbo_depth,0L,0L);    glUseProgram(phongshader);    glClearColor(0.2, 0.0, 0.0, 1.0);    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    //Send info that is the same for all objects (projection, view matrix, light etc)    glUniformMatrix4fv(glGetUniformLocation(phongshader, "projMatrix"), 1, GL_TRUE, projectionMatrix.m);    glUniformMatrix4fv(glGetUniformLocation(phongshader, "viewMatrix"), 1, GL_TRUE, viewMatrix.m);        glUniformMatrix4fv(glGetUniformLocation(phongshader, "normalMatrix"), 1, GL_TRUE, normalMatrix.m);        glUniform3f(glGetUniformLocation(phongshader, "camPosition"),cam.x,cam.y,cam.z);    glUniform1i(glGetUniformLocation(phongshader, "texUnit"), 0);    glUniform3f(glGetUniformLocation(phongshader,"lightPosition"), lightPosition.x, lightPosition.y, lightPosition.z);    //Enable depth tests and all that    // Enable Z-buffering    glEnable(GL_DEPTH_TEST);    // Enable backface culling    glEnable(GL_CULL_FACE);    glCullFace(GL_BACK);    //bunny    glUniformMatrix4fv(glGetUniformLocation(phongshader, "modelMatrix"), 1, GL_TRUE, modelMatrix.m);    DrawModel(bunny, phongshader, "in_Position", "in_Normal", NULL);        //scene        glUniformMatrix4fv(glGetUniformLocation(phongshader, "modelMatrix"), 1, GL_TRUE, bottomModelMatrix.m);    DrawModel(bottom, phongshader, "in_Position", "in_Normal", "in_TexCoord");        glUniformMatrix4fv(glGetUniformLocation(phongshader, "modelMatrix"), 1, GL_TRUE, side1ModelMatrix.m);    DrawModel(side1, phongshader, "in_Position", "in_Normal", "in_TexCoord");        glUniformMatrix4fv(glGetUniformLocation(phongshader, "modelMatrix"), 1, GL_TRUE, side2ModelMatrix.m);    DrawModel(side2, phongshader, "in_Position", "in_Normal", "in_TexCoord");        //ALL LIGHTSURFACES (SAME FBO as PHONG)    glUseProgram(lightShader);    glUniformMatrix4fv(glGetUniformLocation(lightShader, "projMatrix"), 1, GL_TRUE, projectionMatrix.m);    glUniformMatrix4fv(glGetUniformLocation(lightShader, "viewMatrix"), 1, GL_TRUE, viewMatrix.m);        //sphere    glUniformMatrix4fv(glGetUniformLocation(lightShader, "modelMatrix"), 1, GL_TRUE, sphereModelMatrix.m);    DrawModel(sphere, lightShader, "in_Position", NULL, NULL);    //DRAW ALL TRANSLUCENT OBJECTS TO ANOTHER FBO    useFBO(fbo2, 0L, 0L);    glBindTexture(GL_TEXTURE_2D, thicknessTex);	//glClearColor(0.1, 0.1, 0.3, 0);    glClearColor(0.0, 0.0, 0.0, 1.0);    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    glUseProgram(shader);    glUniformMatrix4fv(glGetUniformLocation(shader, "projMatrix"), 1, GL_TRUE, projectionMatrix.m);    glUniformMatrix4fv(glGetUniformLocation(shader, "viewMatrix"), 1, GL_TRUE, viewMatrix.m);        glUniform3f(glGetUniformLocation(shader, "camPosition"),cam.x,cam.y,cam.z);    glUniform3f(glGetUniformLocation(shader,"lightPosition"), lightPosition.x, lightPosition.y, lightPosition.z);    glUniform1i(glGetUniformLocation(shader, "texUnit"), 0);    // Enable Z-buffering    glEnable(GL_DEPTH_TEST);    // Enable backface culling    glEnable(GL_CULL_FACE);    glCullFace(GL_BACK);    //bunny    glUniformMatrix4fv(glGetUniformLocation(shader, "modelMatrix"), 1, GL_TRUE, modelMatrix.m);    DrawModel(bunny, shader, "in_Position", "in_Normal", "in_TexCoord");    //JOIN SHADER    useFBO(fbo3, fbo_depth, 0L); //write to fbo3, read from fbo2 and from fbo1    glUseProgram(joinshader);        glUniform1i(glGetUniformLocation(joinshader, "texUnit"), 0);    glUniform1i(glGetUniformLocation(joinshader, "texUnit2"), 1);        glDisable(GL_CULL_FACE);    glDisable(GL_DEPTH_TEST);    DrawModel(squareModel, joinshader, "in_Position", NULL, "in_TexCoord");    //Pass on Shader    useFBO(0L, fbo3, 0L);       glClearColor(0.0, 0.0, 0.0, 0);    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    glUseProgram(passShader);           glUniform1i(glGetUniformLocation(passShader, "texUnit"), 0);    glDisable(GL_CULL_FACE);    glDisable(GL_DEPTH_TEST);    DrawModel(squareModel, passShader, "in_Position", NULL, "in_TexCoord");    }void reshape(GLsizei w, GLsizei h){    glViewport(0, 0, w, h);    GLfloat ratio = (GLfloat) w / (GLfloat) h;    projectionMatrix = perspective(70, ratio, 0.2, 1000.0);    glUniformMatrix4fv(glGetUniformLocation(shader, "projMatrix"), 1, GL_TRUE, projectionMatrix.m);}//-----------------------------main-----------------------------------------------int main(int argc, char *argv[]){    glutInit(&argc, argv);    glutInitDisplayMode(GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE);    glutInitContextVersion(3, 2); // Might not be needed in Linux    glutInitWindowSize(W, H);    glutCreateWindow ("Sub Surface Scattering Approximation");    glutDisplayFunc(display);    glutTimerFunc(5, &OnTimer, 0);    glutReshapeFunc(reshape);    init();    zprInit(&viewMatrix, cam, point);        glutMainLoop();    exit(0);}